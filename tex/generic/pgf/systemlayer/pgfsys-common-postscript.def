% Copyright 2019 by Till Tantau
% CMYK and grayscale shadings adaptation copyright 2019 by David Purton
% PS-3 shadings, image and opacity masks (fadings), transparency groups,
% blend modes copyright 2020 by Alexander Grahn

%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Public License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.

\ProvidesFileRCS{pgfsys-common-postscript.def}


% Driver commands for postscript

\newif\ifpgf@fillcolor
\newif\ifpgf@strokecolor
\newif\ifpgfsys@@clipnext

% Path construction:
\def\pgfsys@lineto#1#2{\pgf@sys@bp{#1}\pgf@sys@bp{#2}\pgfsysprotocol@literal{lineto}}
\def\pgfsys@moveto#1#2{\pgf@sys@bp{#1}\pgf@sys@bp{#2}\pgfsysprotocol@literal{moveto}}
\def\pgfsys@curveto#1#2#3#4#5#6{%
  \pgf@sys@bp{#1}\pgf@sys@bp{#2}\pgf@sys@bp{#3}\pgf@sys@bp{#4}\pgf@sys@bp{#5}\pgf@sys@bp{#6}\pgfsysprotocol@literal{curveto}}
\def\pgfsys@rect#1#2#3#4{\pgf@sys@bp{#4}\pgf@sys@bp{#3}\pgf@sys@bp{#1}\pgf@sys@bp{#2}\pgfsysprotocol@literal{pgfe}}
\def\pgfsys@closepath{\pgfsysprotocol@literal{closepath}}

% Path usage:
\def\pgfsys@stroke{%
  \ifpgfsys@@clipnext%
    \ifpgfsys@eorule%
      \pgfsysprotocol@literal{gsave pgfsc pgfstr grestore eoclip newpath}%
    \else%
      \pgfsysprotocol@literal{gsave pgfsc pgfstr grestore clip newpath}%
    \fi%
    \pgfsys@@clipnextfalse%
  \else%
    \ifpgf@strokecolor%
      \pgfsysprotocol@literal{gsave pgfsc pgfstr grestore newpath}%
    \else%
      \pgfsysprotocol@literal{pgfstr}%
    \fi%
 \fi}
\def\pgfsys@fill{%
  \ifpgfsys@@clipnext%
    \ifpgfsys@eorule%
      \pgfsysprotocol@literal{gsave pgffc pgfeofill grestore eoclip newpath}%
    \else%
      \pgfsysprotocol@literal{gsave pgffc pgffill grestore clip newpath}%
    \fi%
    \pgfsys@@clipnextfalse%
  \else%
    \ifpgf@fillcolor%
      \ifpgfsys@eorule%
        \pgfsysprotocol@literal{gsave pgffc pgfeofill grestore newpath}%
      \else%
        \pgfsysprotocol@literal{gsave pgffc pgffill grestore newpath}%
      \fi%
    \else%
      \ifpgfsys@eorule%
        \pgfsysprotocol@literal{pgfeofill}%
      \else%
        \pgfsysprotocol@literal{pgffill}%
      \fi%
    \fi%
 \fi}
\def\pgfsys@fillstroke{%
  \ifpgfsys@eorule%
    \pgfsysprotocol@literal{gsave pgffc pgfeofill grestore gsave pgfsc pgfstr grestore}%
  \else%
    \pgfsysprotocol@literal{gsave pgffc pgffill grestore gsave pgfsc pgfstr grestore}%
  \fi%
  \ifpgfsys@@clipnext%
    \ifpgfsys@eorule%
      \pgfsysprotocol@literal{eoclip}%
    \else%
      \pgfsysprotocol@literal{clip}%
    \fi%
    \pgfsys@@clipnextfalse%
  \fi%
  \pgfsysprotocol@literal{newpath}}
\def\pgfsys@clipnext{\pgfsys@@clipnexttrue}
\def\pgfsys@discardpath{%
  \ifpgfsys@@clipnext%
    \ifpgfsys@eorule%
      \pgfsysprotocol@literal{%
        /pgfsmaskinplace dup where {exch get}{pop false} ifelse not {eoclip} if}%
    \else%
      \pgfsysprotocol@literal{%
        /pgfsmaskinplace dup where {exch get}{pop false} ifelse not {clip} if}%
    \fi%
    \pgfsys@@clipnextfalse%
  \fi%
  \pgfsysprotocol@literal{newpath}}

% Transformation:
\def\pgfsys@transformshift#1#2{\pgf@sys@bp{#1}\pgf@sys@bp{#2}\pgfsysprotocol@literal{translate}}
\def\pgfsys@transformxyscale#1#2{\pgfsysprotocol@literal{#1 #2 scale}}
\def\pgfsys@transformcm#1#2#3#4#5#6{%
  \pgfsysprotocol@literalbuffered{[#1 #2 #3 #4}\pgf@sys@bp{#5}\pgf@sys@bp{#6}\pgfsysprotocol@literal{] concat}}

% Scopes
\def\pgfsys@beginscope{\pgfsysprotocol@literal{save}}
\def\pgfsys@endscope{\pgfsysprotocol@literal{restore}}

\newif\ifpgfsys@ps@boxmode
\def\pgfsys@begin@text{\pgfsys@ps@boxmodetrue}
\def\pgfsys@end@text{}


% Graphics state
\def\pgfsys@setdash#1#2{%
  \pgfsysprotocol@literalbuffered{[}%
  \pgfutil@for\pgf@sys@temp:={#1}\do{\pgf@sys@bp{\pgf@sys@temp}}%
  \pgfsysprotocol@literalbuffered{]}%
  \pgf@sys@bp{#2}\pgfsysprotocol@literal{setdash}}
\def\pgfsys@setlinewidth#1{\pgf@sys@bp{#1}\pgfsysprotocol@literal{pgfw}}
\def\pgfsys@setmiterlimit#1{\pgfsysprotocol@literal{#1 setmiterlimit}}
\def\pgfsys@buttcap{\pgfsysprotocol@literal{0 setlinecap}}
\def\pgfsys@roundcap{\pgfsysprotocol@literal{1 setlinecap}}
\def\pgfsys@rectcap{\pgfsysprotocol@literal{2 setlinecap}}
\def\pgfsys@miterjoin{\pgfsysprotocol@literal{0 setlinejoin}}
\def\pgfsys@roundjoin{\pgfsysprotocol@literal{1 setlinejoin}}
\def\pgfsys@beveljoin{\pgfsysprotocol@literal{2 setlinejoin}}
\def\pgfsys@color@rgb@stroke#1#2#3{\pgfsysprotocol@literal{/pgfsc{#1 #2 #3 setrgbcolor}def}\pgf@strokecolortrue}
\def\pgfsys@color@rgb@fill#1#2#3{\pgfsysprotocol@literal{/pgffc{#1 #2 #3 setrgbcolor}def}\pgf@fillcolortrue}
\def\pgfsys@color@rgb#1#2#3{\pgfsys@color@reset\pgfsysprotocol@literal{#1 #2 #3 setrgbcolor}}
\def\pgfsys@color@cmyk@stroke#1#2#3#4{\pgfsysprotocol@literal{/pgfsc{#1 #2 #3 #4 setcmykcolor}def}\pgf@strokecolortrue}
\def\pgfsys@color@cmyk@fill#1#2#3#4{\pgfsysprotocol@literal{/pgffc{#1 #2 #3 #4 setcmykcolor}def}\pgf@fillcolortrue}
\def\pgfsys@color@cmyk#1#2#3#4{\pgfsys@color@reset\pgfsysprotocol@literal{#1 #2 #3 #4 setcmykcolor}}
\def\pgfsys@color@cmy@stroke#1#2#3{\pgfsysprotocol@literal{/pgfsc{#1 #2 #3 0 setcmykcolor}def}\pgf@strokecolortrue}
\def\pgfsys@color@cmy@fill#1#2#3{\pgfsysprotocol@literal{/pgffc{#1 #2 #3 0 setcmykcolor}def}\pgf@fillcolortrue}
\def\pgfsys@color@cmy#1#2#3{\pgfsys@color@reset\pgfsysprotocol@literal{#1 #2 #3 0 setcmykcolor}}
\def\pgfsys@color@gray@stroke#1{\pgfsysprotocol@literal{/pgfsc{#1 setgray}def}\pgf@strokecolortrue}
\def\pgfsys@color@gray@fill#1{\pgfsysprotocol@literal{/pgffc{#1 setgray}def}\pgf@fillcolortrue}
\def\pgfsys@color@gray#1{\pgfsys@color@reset\pgfsysprotocol@literal{#1 setgray}}
\def\pgfsysps@color@resetnow{\pgfsysprotocol@literal{/pgfsc{}def/pgffc{}def}\pgf@strokecolorfalse\pgf@fillcolorfalse}%
\def\pgfsys@color@reset{%
  \ifpgfsys@color@reset@inorder%
    \ifpgf@strokecolor%
      \pgfsysps@color@resetnow%
    \else%
      \ifpgf@fillcolor%
        \pgfsysps@color@resetnow%
      \fi%
    \fi%
  \else%
    \pgfsysps@color@resetnow%
  \fi}


%
% Opacity
%

\def\pgfsys@fill@opacity#1{%
  \pgfsysprotocol@literal{#1 .pgfsetfillopacityalpha}%
}
\def\pgfsys@stroke@opacity#1{%
  \pgfsysprotocol@literal{#1 .pgfsetstrokeopacityalpha}%
}

% Objects
\newcount\pgf@objectcount
\def\pgfsys@defobject#1#2#3#4{%
  \global\advance\pgf@objectcount by 1%
  \expandafter\xdef\csname#1\endcsname{\the\pgf@objectcount}%
  \pgfsysprotocol@getcurrentprotocol\pgfsys@temp%
  {%
    \pgfsysprotocol@setcurrentprotocol\pgfutil@empty%
    \pgfsysprotocol@bufferedtrue%
    #4%
    \pgfsysprotocol@getcurrentprotocol\pgfsys@@temp%
    \pgf@sys@postscript@object{/pgf\csname#1\endcsname{gsave exec \pgfsys@@temp\space grestore} bind def}%
  }%
  \pgfsysprotocol@setcurrentprotocol\pgfsys@temp%
}
\def\pgfsys@useobject#1#2{%
  \pgfsysprotocol@getcurrentprotocol\pgfsys@temp%
  {%
    \pgfsysprotocol@setcurrentprotocol\pgfutil@empty%
    \pgfsysprotocol@bufferedfalse%
    #2%
    \pgfsysprotocol@invokecurrentprotocol%
    \pgfsys@invoke{pgf\csname#1\endcsname}%
  }%
  \pgfsysprotocol@setcurrentprotocol\pgfsys@temp}

% Blending
\def\pgfsys@blend@mode#1{%
  \expandafter\ifx\csname pgf@sys@pdf@bm@#1\endcsname\relax%
    \expandafter\let\expandafter\pgf@temp\csname pgf@sys@pdf@blend@mode@map@#1\endcsname%
    \expandafter\xdef\csname pgf@sys@pdf@bm@#1\endcsname{/\pgf@temp}%
    \ifx\pgf@temp\relax%
      \pgferror{Unknown blend mode '#1'}%
      \def\pgf@temp{Normal}%
    \fi%
  \fi%
  \pgfsysprotocol@literal{\csname pgf@sys@pdf@bm@#1\endcsname\space .setblendmode}%
}
\expandafter\def\csname pgf@sys@pdf@blend@mode@map@normal\endcsname{Normal}
\expandafter\def\csname pgf@sys@pdf@blend@mode@map@multiply\endcsname{Multiply}
\expandafter\def\csname pgf@sys@pdf@blend@mode@map@screen\endcsname{Screen}
\expandafter\def\csname pgf@sys@pdf@blend@mode@map@overlay\endcsname{Overlay}
\expandafter\def\csname pgf@sys@pdf@blend@mode@map@darken\endcsname{Darken}
\expandafter\def\csname pgf@sys@pdf@blend@mode@map@lighten\endcsname{Lighten}
\expandafter\def\csname pgf@sys@pdf@blend@mode@map@color dodge\endcsname{ColorDodge}
\expandafter\def\csname pgf@sys@pdf@blend@mode@map@color burn\endcsname{ColorBurn}
\expandafter\def\csname pgf@sys@pdf@blend@mode@map@hard light\endcsname{HardLight}
\expandafter\def\csname pgf@sys@pdf@blend@mode@map@soft light\endcsname{SoftLight}
\expandafter\def\csname pgf@sys@pdf@blend@mode@map@difference\endcsname{Difference}
\expandafter\def\csname pgf@sys@pdf@blend@mode@map@exclusion\endcsname{Exclusion}
\expandafter\def\csname pgf@sys@pdf@blend@mode@map@saturation\endcsname{Saturation}
\expandafter\def\csname pgf@sys@pdf@blend@mode@map@color\endcsname{Color}
\expandafter\def\csname pgf@sys@pdf@blend@mode@map@hue\endcsname{Hue}
\expandafter\def\csname pgf@sys@pdf@blend@mode@map@luminosity\endcsname{Luminosity}


%
% Shadings
%

\def\pgfsys@horishading#1#2#3{%
  {%
    \pgf@parsefunc{#3}%
    \pgf@xb=\pgf@max
    \pgfmathsetlength\pgf@y{#2}%
    \pgf@yb=\pgf@y%
    \pgf@sys@bp@correct{\pgf@xb}%
    \pgf@sys@bp@correct{\pgf@yb}%
    \xdef\pgfutil@tempa{\hbox to \the\pgf@max{%
      \noexpand\vrule width0pt height\the\pgf@y%
      \noexpand\pgfsys@beginpurepicture%
        \noexpand\pgfsys@outerinvoke{
          \pgf@sys@tonumber{\pgf@yb} \pgf@sys@tonumber{\pgf@xb} 0 0 pgfe <<
            /PatternType 2
            /Shading <<
              /ShadingType 2
              /ColorSpace \pgf@shading@device\space
              /Domain [\pgf@pdfparseddomain]
              /Coords [\pgf@doma\space0 \pgf@domb\space0]
              /Function \pgf@pdfparsedfunction
            >>
          >> matrix makepattern setpattern fill
        }%
        \hss%
      \noexpand\pgfsys@endpurepicture%
    }}%
  }%
  \global\expandafter\let\csname @pgfshading#1!\endcsname=\pgfutil@tempa%
}
\def\pgfsys@vertshading#1#2#3{%
  {%
    \pgf@parsefunc{#3}%
    \pgfmathsetlength\pgf@x{#2}%
    \pgf@xb=\pgf@x%
    \pgf@yb=\pgf@max
    \pgf@sys@bp@correct{\pgf@xb}%
    \pgf@sys@bp@correct{\pgf@yb}%
    \xdef\pgfutil@tempa{\hbox to \the\pgf@x{%
      \noexpand\vrule width0pt height\the\pgf@max%
      \noexpand\pgfsys@beginpurepicture%
        \noexpand\pgfsys@outerinvoke{
          \pgf@sys@tonumber{\pgf@yb} \pgf@sys@tonumber{\pgf@xb} 0 0 pgfe <<
            /PatternType 2
            /Shading <<
              /ShadingType 2
              /ColorSpace \pgf@shading@device\space
              /Domain [\pgf@pdfparseddomain]
              /Coords [0 \pgf@doma\space0 \pgf@domb]
              /Function \pgf@pdfparsedfunction
            >>
          >> matrix makepattern setpattern fill
        }%
        \hss%
      \noexpand\pgfsys@endpurepicture%
    }}%
  }%
  \global\expandafter\let\csname @pgfshading#1!\endcsname=\pgfutil@tempa%
}
\def\pgfsys@radialshading#1#2#3{%
  {%
    \pgf@parsefunc{#3}%
    \pgf@process{#2}%
    \pgf@xa=\pgf@x%
    \pgf@ya=\pgf@y%
    \pgf@process{\pgfpoint{\pgf@max}{\pgf@max}}%
    \advance\pgf@xa by \pgf@x%
    \advance\pgf@ya by \pgf@y%
    \pgf@sys@bp@correct{\pgf@x}%
    \pgf@sys@bp@correct{\pgf@y}%
    \pgf@sys@bp@correct{\pgf@xa}%
    \pgf@sys@bp@correct{\pgf@ya}%
    \pgf@max=2\pgf@max%
    \xdef\pgfutil@tempa{\hbox to \the\pgf@max{%
      \noexpand\vrule width0pt height\the\pgf@max%
      \noexpand\pgfsys@beginpurepicture%
        \noexpand\pgfsys@outerinvoke{
          <<
            /ShadingType 3
            /ColorSpace \pgf@shading@device\space
            /Domain [\pgf@pdfparseddomain]
            /Coords [\pgf@sys@tonumber{\pgf@xa} \pgf@sys@tonumber{\pgf@ya} \pgf@doma\space
              \pgf@sys@tonumber{\pgf@x} \pgf@sys@tonumber{\pgf@y} \pgf@domb]
            /Function \pgf@pdfparsedfunction
            /Extend [true false]
          >> shfill
        }%
        \hss%
      \noexpand\pgfsys@endpurepicture%
    }}%
  }%
  \global\expandafter\let\csname @pgfshading#1!\endcsname=\pgfutil@tempa
}
\def\pgfsys@functionalshading#1#2#3#4{%
  {%
    \pgf@process{#2}%
    \pgf@xa=\pgf@x%
    \pgf@ya=\pgf@y%
    \pgf@process{#3}%
    \pgf@xb=\pgf@x%
    \pgf@yb=\pgf@y%
    \advance\pgf@x by-\pgf@xa%
    \advance\pgf@y by-\pgf@ya%
    \pgf@sys@bp@correct{\pgf@xa}%
    \pgf@sys@bp@correct{\pgf@ya}%
    \pgf@sys@bp@correct{\pgf@xb}%
    \pgf@sys@bp@correct{\pgf@yb}%
    \pgf@xc=-\pgf@xa%
    \pgf@yc=-\pgf@ya%
    \xdef\pgfutil@tempa{%
      \hbox to\the\pgf@x{\vbox to\the\pgf@y{\vfil
          \noexpand\pgfsys@beginpurepicture%
          \noexpand\pgfsys@invoke{%
            % patch coords
            /pgfpatchllx \pgf@sys@tonumber{\pgf@xa} def
            /pgfpatchlly \pgf@sys@tonumber{\pgf@ya} def
            % shading patch width and height
            /pgfpatchX \pgf@sys@tonumber{\pgf@xb} pgfpatchllx sub def
            /pgfpatchY \pgf@sys@tonumber{\pgf@yb} pgfpatchlly sub def
            % number of samples in each direction
            pgfpatchX pgfpatchY pgfnumsamples\pgf@shading@model /pgfsamplesy exch def /pgfsamplesx exch def
            % sample distance in each direction, in bp
            /pgfpatchdx pgfpatchX pgfsamplesx 1 sub div def /pgfpatchdy pgfpatchY pgfsamplesy 1 sub div def
            % allocate DataSource string
            /pgfdatasource pgfsamplesx pgfsamplesy mul pgfsamplesize\pgf@shading@model\space mul string def
            %
            pgfpatchllx neg pgfpatchlly neg translate
            /pgfproc {#4} bind def
            %
            %fill `pgfdatasource' string with colour samples
            0 1 pgfsamplesy 1 sub
            {
              0 1 pgfsamplesx 1 sub
              { % j i
                1 index exch 2 copy % j j i j i
                exch pgfsamplesx mul add % j j i sampleidx
                pgfdatasource exch 4 2 roll % j datasource sampleidx j i
                pgfpatchdx mul pgfpatchllx add exch
                pgfpatchdy mul pgfpatchlly add pgfproc % j datasource sampleindex <colour>
                pgfputstring\pgf@shading@model % j
              } for
              pop
            } for
            pgfpatchY pgfpatchX pgfpatchllx pgfpatchlly pgfe <<
              /PatternType 2
              /Shading <<
                /ShadingType 1
                /Domain [0 1 0 1]
                /Matrix [pgfpatchX 0 0 pgfpatchY pgfpatchllx pgfpatchlly]
                /ColorSpace \pgf@shading@device\space
                /Function <<
                  /FunctionType 0
                  /Order 3 % splines
                  /Domain [0 1 0 1]
                  /Range pgfrange\pgf@shading@model
                  /BitsPerSample pgfchanneldepth\pgf@shading@model % bits per channel, actually
                  /Size [pgfsamplesx pgfsamplesy]
                  /DataSource pgfdatasource
                >>
              >>
            >> matrix makepattern setpattern fill
          }%
        \noexpand\pgfsys@endpurepicture
      }\hss}%
    }%
  }%
  \global\expandafter\let\csname @pgfshading#1!\endcsname=\pgfutil@tempa
}

% helpers for converting FunctionType-4 to FunctionType-0, i. e. sampled, function;
% FunctionType-4 functions are not defined in PostScript-3
%
% Colours in the rectangular shading patch are sampled and stored in a
% string which is passed as value to the /DataSource key in the /FunctionType 0
% dictionary. However, PostScript imposes a limit of 65535 characters (bytes) per
% string. To meet this requirement, we calculate the number of samples in x and y,
% taking into account the patch dimensions and the colour depth of the colour
% channels. Also, the distance between colour samples should not be less than 1bp
% in x and y.
%
% The table summarizes the different colour models we are going to use:
% ------+-------------------+-----------+------------------+----------------------
% model | channel depth/bit | max value | sample size/byte | max number of samples
% ------+-------------------+-----------+------------------+----------------------
%  cmyk |                 8 |       255 |                4 |                 16383
%   rgb |                 8 |       255 |                3 |                 21845
%  gray |                24 |  16777215 |                3 |                 21845
% ------+-------------------+-----------+------------------+----------------------

\pgf@sys@postscript@header{
  %
  % X Y pgfnumsamples(cmyk|rgb|gray) ==> nx ny
  % patch dimensions X, Y in bp; number of samples nx, ny;
  %
  /pgfnumsamplescmyk {
    % samples in x
    2 copy div 16383 mul sqrt round cvi       % X Y nx
    % sample distance no less than 1bp
    dup 1 sub 3 index gt {pop 1 index cvi 1 add} if
    % samples in y
    dup 16383 exch div cvi                 % X Y nx ny
    % sample distance no less than 1bp
    dup 1 sub 3 index gt {pop 1 index cvi 1 add} if
    4 -2 roll pop pop                            % nx ny
  } bind def
  %
  /pgfnumsamplesrgb {
    2 copy div 21845 mul sqrt round cvi
    dup 1 sub 3 index gt {pop 1 index cvi 1 add} if
    dup 21845 exch div cvi
    dup 1 sub 3 index gt {pop 1 index cvi 1 add} if
    4 -2 roll pop pop
  } bind def
  %
  /pgfnumsamplesgray /pgfnumsamplesrgb load def
  %
  % -str- sampleindex c m y k pgfputstringcmyk ==> (nothing pushed)
  % -str- sampleindex r g b   pgfputstringrgb  ==>
  % -str- sampleindex gray    pgfputstringgray ==>
  % put colour sample at given sample index into the /DataSource string;
  % colour components (c,m,y,k; r,g,b; gray) between 0.0 to 1.0
  %
  /pgfputstringcmyk {
    5 index 5 index 4 mul       5 index pgfcheckcolorrange 255 mul round cvi put
    5 index 5 index 4 mul 1 add 4 index pgfcheckcolorrange 255 mul round cvi put
    5 index 5 index 4 mul 2 add 3 index pgfcheckcolorrange 255 mul round cvi put
    5 index 5 index 4 mul 3 add 2 index pgfcheckcolorrange 255 mul round cvi put
    pop pop pop pop pop pop
  } bind def
  %
  /pgfputstringrgb {
    4 index 4 index 3 mul       4 index pgfcheckcolorrange 255 mul round cvi put
    4 index 4 index 3 mul 1 add 3 index pgfcheckcolorrange 255 mul round cvi put
    4 index 4 index 3 mul 2 add 2 index pgfcheckcolorrange 255 mul round cvi put
    pop pop pop pop pop
  } bind def
  %
  /pgfputstringgray {
    % grayvalue between 0 and 16777215 (24 bit)
    pgfcheckcolorrange 16777215 mul round cvi % -str- sampleindex gray24
    % put high byte
    2 index 2 index 3 mul       2 index          16 neg bitshift put
    % put middle byte
    2 index 2 index 3 mul 1 add 2 index 65535 and 8 neg bitshift put
    % put low byte
    2 index 2 index 3 mul 2 add 2 index   255 and                put
    pop pop pop
  } bind def
  %
  % <colour component> pgfcheckcolorrange ==> <something between 0.0 and 1.0>
  % truncates value to the allowed range (user-defined Type-4 functions may
  % happen to provide values outside this range)
  /pgfcheckcolorrange {
    dup 0.0 ge not {pop 0.0} if
    dup 1.0 le not {pop 1.0} if
  } bind def
  %
  %colour depths per channel (bit)
  /pgfchanneldepthcmyk 8 def
  /pgfchanneldepthrgb 8 def
  /pgfchanneldepthgray 24 def
  %
  %colour sample size (byte)
  /pgfsamplesizecmyk 4 def
  /pgfsamplesizergb 3 def
  /pgfsamplesizegray 3 def
  %
  %/Range array in the FunctionType 0 dictionary
  /pgfrangecmyk [0 1 0 1 0 1 0 1] def
  /pgfrangergb [0 1 0 1 0 1] def
  /pgfrangegray [0 1] def
}

%
% Patterns
%

\def\pgfsys@declarepattern#1#2#3#4#5#6#7{%
  % Start building the pattern dictionary:
  \pgf@xa=#2\relax%
  \pgf@ya=#3\relax%
  \pgf@xb=#4\relax%
  \pgf@yb=#5\relax%
  \pgf@xc=#6\relax%
  \pgf@yc=#7\relax%
  \pgf@sys@bp@correct\pgf@xa%
  \pgf@sys@bp@correct\pgf@ya%
  \pgf@sys@bp@correct\pgf@xb%
  \pgf@sys@bp@correct\pgf@yb%
  \pgf@sys@bp@correct\pgf@xc%
  \pgf@sys@bp@correct\pgf@yc%
  \pgfsys@@declarepattern{#1}%
}

\def\pgfsys@@declarepattern#1#2#3#4#5#6#7#8#9{%
  \pgfutil@tempdima=#6\relax%
  \pgfutil@tempdimb=#7\relax%
  \pgf@sys@bp@correct\pgfutil@tempdima%
  \pgf@sys@bp@correct\pgfutil@tempdimb%
  \edef\pgf@sys@marshal{%
  \noexpand\pgfutil@insertatbegincurrentpage{\noexpand\pgfsys@outerinvoke{
    save true setglobal globaldict begin /pgfpat#1
    {
    \ifnum#9=0 [/Pattern /DeviceRGB] \else /Pattern \fi\space
    setcolorspace
    gsave
    initgraphics
    <<
      /Type /Pattern
      /PatternType 1
      /PaintType \ifnum#9=0 2 \else 1 \fi
      /TilingType 1
      /BBox [\pgf@sys@tonumber\pgf@xa\space\pgf@sys@tonumber\pgf@ya\space\pgf@sys@tonumber\pgf@xb\space\pgf@sys@tonumber\pgf@yb]
      /XStep \pgf@sys@tonumber\pgf@xc\space
      /YStep \pgf@sys@tonumber\pgf@yc\space
      /Matrix [#2\space#3\space#4\space#5\space\pgf@sys@tonumber\pgfutil@tempdima\space\pgf@sys@tonumber\pgfutil@tempdimb]
      /PaintProc
      { begin 2 dict begin #8\space end end } bind
    >>
    matrix
    makepattern
    %/pgfpat#1\space exch def
    grestore
    setcolor
    } bind def end restore
  }}% <<
  }%
  \pgf@sys@marshal%
}

\def\pgfsys@setpatternuncolored#1#2#3#4{%
  \pgfsysprotocol@literal{/pgffc{#2 #3 #4 pgfpat#1}def}%
%      [/Pattern /DeviceRGB] setcolorspace
%      #2 #3 #4 pgfpat#1\space setcolor
%    }def}%
  \pgf@fillcolortrue%
}

\def\pgfsys@setpatterncolored#1{%
  \pgfsysprotocol@literal{/pgffc{pgfpat#1}def}%/Pattern setcolorspace
%      pgfpat#1\space setcolor}def}%
  \pgf@fillcolortrue%
}


%
% Opacity masks
%

\def\pgfsys@fadingfrombox#1#2{%
  \ifcsname pgfsmaskxform@#1\endcsname
    \pgfwarning{Fading '#1' already defined.\MessageBreak Going to replace it with new definition}%
  \fi%
  \global\advance\pgf@objectcount\@ne%
  {%
    \pgf@x=-.5\wd#2%
    \pgf@y=-.5\ht#2%
    \advance\pgf@y by.5\dp#2%
    \expandafter\xdef\csname pgfsmasktrans@#1\endcsname{%
      \noexpand\pgftransformcm{1}{0}{0}{1}{\noexpand\pgfqpoint{\the\pgf@x}{\the\pgf@y}}}%
    \edef\@tempa{\noexpand\pgfutil@insertatbegincurrentpagefrombox{%
      % box coordinates (reference point and top) needed for distilling
      \pgfsys@outerinvoke{currentpoint /pgf@refy exch def /pgf@refx exch def}%
      \hbox to 0pt {\hbox to \ifdim\ht#2>\ht\strutbox\ht#2\else\ht\strutbox\fi{\hss\pgfsys@outerinvoke{%
        /pgf@top pgf@refy currentpoint pop pgf@refx sub VResolution Resolution div mul sub def%
      }}\hss}%
      \pgfsys@outerinvoke{gsave
        % translate box to upper left page corner, so we have the whole clipping path (i. e.
        % page area) available for distilling, as outlying parts get clipped
        clippath pathbbox newpath pop pop translate pgf@refx neg pgf@top neg translate
        % translate origin (0,0) to the reference point
        gsave pgf@refx pgf@refy translate
        mark /_objdef {pgfsmaskxform@\the\pgf@objectcount}
          /BBox [clippath pathbbox newpath] /BP pdfmark grestore%
      }%
      \wd#2=0pt\ht#2=0pt\dp#2=0pt%
      \box#2%
      \pgfsys@outerinvoke{mark /EP pdfmark grestore}%
    }}\@tempa%
    \expandafter\xdef\csname pgfsmaskxform@#1\endcsname{\the\pgf@objectcount}%
  }%
}
\def\pgfsys@usefading#1#2#3#4#5#6#7{%
  \ifcsname pgfsmaskxform@#1\endcsname%
  {%
     \pgftransformreset%
     \pgftransformcm{#2}{#3}{#4}{#5}{\pgfpoint{#6}{#7}}%
     \csname pgfsmasktrans@#1\endcsname%
     {%
       \pgflowlevelsynccm%
       \pgfsys@outerinvoke{%
         /.begintransparencymaskgroup where {pop
           /pgf@sys@currentcolorspace currentcolorspace def
           /pgf@sys@currentcolor [currentcolor] cvx def
           /pgf@sys@OverrideICC currentuserparams /OverrideICC get def % Chr. Liddell
           <</OverrideICC true>> setuserparams                         % of Artifex
           /DeviceGray setcolorspace
           true <</Subtype/Luminosity>> clippath pathbbox newpath .begintransparencymaskgroup
           gsave
           72 Resolution div 72 VResolution div scale
           1 DVImag div 1 DVImag div neg scale
           mark {pgfsmaskxform@\csname pgfsmaskxform@#1\endcsname} /SP pdfmark
           grestore
           0 .endtransparencymask
           <</OverrideICC pgf@sys@OverrideICC>> setuserparams % restore orig. settings
           pgf@sys@currentcolorspace setcolorspace
           pgf@sys@currentcolor setcolor
           /pgfsmaskinplace true def
         } if%
       }%
     }%
     \pgftransforminvert%
     \pgflowlevelsynccm%
  }%
  \else
    \pgferror{Undefined fading '#1'}%
  \fi%
}
\def\pgfsys@@clipfading{%
  \pgfsyssoftpath@invokecurrentpath%
  \pgfsys@clipnext%
  \pgfsys@discardpath%
}


%
% Transparency groups
%
\def\pgfsys@transparencygroupfrombox#1{%
  \global\advance\pgf@objectcount\@ne%
  \pgfsys@outerinvoke{%
    mark /_objdef {pgfxform@\the\pgf@objectcount} /BBox [clippath pathbbox newpath] /BP pdfmark
    gsave
    /pgf@sys@foa pgffoa def /pgf@sys@soa pgfsoa def
    /.setstrokeconstantalpha where
      {pop 1 .pgfsetfillopacityalpha 1 .pgfsetstrokeopacityalpha} if%
  }%
  \wd#1=0pt\ht#1=0pt\dp#1=0pt%
  \hskip\pgf@picminx\box#1%
  \pgfsys@outerinvoke{%
    /pgffoa pgf@sys@foa def /pgfsoa pgf@sys@soa def
    grestore
    mark /EP pdfmark
    mark {pgfxform@\the\pgf@objectcount} << /Group << /S /Transparency
      /I \ifpgfsys@transparency@group@isolated true \else false \fi
      /K \ifpgfsys@transparency@group@knockout true \else false \fi  >> >> /PUT pdfmark%
  }%
  \setbox#1=\hbox{\pgfsys@outerinvoke{mark {pgfxform@\the\pgf@objectcount} /SP pdfmark}}%
}

\endinput

%%% Local Variables:
%%% mode: latex
%%% End:
