% Copyright 2019 by Jonathan P. Spratte
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Public License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.

\section{ParserX Module}
\label{section-module-parserx}

\begin{pgfmodule}{parserx}
  This module extends the ideas of the |parser| module in
  section~\ref{section-module-parser}.
\end{pgfmodule}

This module provides commands for defining a parser that scans some given text
letter-by-letter just like the |parser| module. In addition the rules for each
letter might take optional or mandatory arguments, you can define an action for
unknown letters and a final macro that is executed after the state is
switched to |final|.

Since the idea of this module is based on the idea of |parser|, this section
mainly highlights the differences and doesn't describe the basic idea, you
should first read section~\ref{section-module-parser}.

As for the |parser| module you shouldn't call another parser from inside an
action of a parser unless you put it in a scope. However |parser| and |parserx|
don't share any internal code or state variables. Therefore it is safe to nest a
parser defined with the |parser| module inside one defined with the |parserx|
module and vice versa.

\begin{command}{\pgfparserxrun\marg{parser name}\meta{text}}
  This is the equivalent of |\pgfparserparse| in the |parser| module. It parses
  \meta{text} according to the rules defined for the parser \meta{parser name}.
  Initially every parser's state is |initial|. Parsing will end once the state
  is switched to |final|. Unlike the |parser| module spaces are ignored by
  default although you can define an action for them.
\end{command}

\begin{command}
  {%
    \pgfparserxdef\marg{parser name}\marg{state}\meta{symbol meaning}%
    \oarg{arguments}\marg{action}%
  }
  This command is used to define a rule for the parser \meta{parser name} in the
  state \meta{state}. The \meta{symbol meaning} can either be the symbol meaning
  as you'd provide it in the |parser| module in braces, or be the letter
  without braces around it. There are two letters that can't be defined this
  way: |{| and a blank space. For the first you can use |\bgroup| instead
  and a blank space is definable with |{blank space}|.
  \meta{arguments} is an argument string and can contain up to nine arguments.
  The following are the available argument types:

  \begingroup
  \def\argdesc#1#2%
    {%
      \par
      \begingroup
      \setbox0\hbox{\texttt #1}\makebox[1.5em][l]{\usebox0}%
      \ifdim\wd0>1.5em\\\null\hspace{1.5em}\fi
      \parbox[t]{\dimexpr\linewidth-1.5em\relax}{#2}%
      \endgroup
    }%
    \argdesc{m}
      {a normal mandatory argument}
    \argdesc{r\meta{delim}}
      {a mandatory argument which is read up to the \meta{delim}}
    \argdesc{o}
      {an optional argument in |[]| defaulting to a special mark}
    \argdesc{O\marg{default}}
      {like |o| but defaulting to \meta{default}}
    \argdesc{d\meta{delim1}\meta{delim2}}
      {%
        an optional argument in \meta{delim1} and \meta{delim2} defaulting to a
        special mark%
      }
    \argdesc{D\meta{delim1}\meta{delim2}\marg{default}}
      {like |d| but defaulting to \meta{default}}
    \argdesc{t\meta{token}}
      {%
        tests whether the next letter is \meta{token}, if so gobbles it and
        the argument is set to a special mark.%
      }
  \endgroup

  So if you want to define an \meta{action} that takes two mandatory arguments
  you use |[mm]|, if it should take an optional star, one optional argument in
  brackets that returns a marker if it's not used, one mandatory and finally an
  optional argument in parentheses that defaults to |something| you use
  |[t*omD(){something}]| as the argument string. If the argument should be
  anything up to a semicolon, you use |[r;]|. Spaces before argument
  specifications in the string are ignored. So |[r m]| will be one argument and
  read anything up to an |m|. Also spaces before any argument in the parsed
  letters are ignored, so if |a| was setup to take an optional argument the
  argument would be detected in |a []|. Like with normal \LaTeXe\ optional
  arguments you have to protect nested brackets: |[a[bc]d]| would be read as
  |a[bc| with a trailing |d]|, \emph{not} as |a[bc]d|. You'd have to use
  |[{a[bc]d}]| to get it correct.

  The code which should be executed for \meta{symbol meaning} is set to
  \meta{action}. Each \meta{action} is appended by an internal macro of the
  module that parses the next letter.

  Just like in the |parser| module the special \meta{state} |all| can be used.
\end{command}

\begin{command}
  {%
    \pgfparserxlet
    \marg{parser name 1}\marg{state 1}\meta{symbol meaning 1}%
    \oarg{opt 1}\oarg{opt 2}\meta{symbol meaning 2}%
  }
  If none of of the optional arguments are given in the following \meta{parser
  name 2} and \meta{state 2} are the same as \meta{parser name 1} and
  \meta{state 1}. If only the first is given \meta{state 2} equals
  \meta{opt 1}. If both are given \meta{parser name 2} equals \meta{opt 1} and
  \meta{state 2} equals \meta{opt 2}.

  Defines an action for \meta{parser name 1} in \meta{state 1} for the
  \meta{symbol meaning 1} to do the same as the action of \meta{parser name 2}
  in \meta{state 2} for the \meta{symbol meaning 2}. For \meta{symbol meaning 1}
  and \meta{symbol meaning 2} the same parsing rules apply as for \meta{symbol
  meaning} in |\pgfparserxdef| so you either give the meaning in braces or just
  the symbol.
\end{command}

\begin{command}
  {\pgfparserxdefunknown\marg{parser name}\marg{state}\marg{action}}
  With this macro you can define an \meta{action} for the \meta{parser name}
  parser if the letter which was encountered was undefined.
\end{command}

\begin{command}{\pgfparserxdeffinal\marg{parser name}\marg{action}}
  Every parser can call a final \meta{action} after the state was switched to
  |final|. This \meta{action} is executed after everything else, so you can use
  something that grabs more arguments if you want to.
\end{command}

\begin{command}{\pgfparserxswitch\marg{state}}
  Set the state of the parser to \meta{state}, can be used inside the action
  code of a parser.
\end{command}

\begin{command}{\pgfparserxifmark\marg{arg}\marg{true}\marg{false}}
  Remember that some of the optional argument types set special marks? With
  |\pgfparserxifmark| you can test whether \meta{arg} is such a mark. So if
  there was no optional argument for the argument types |o| and |d| the
  \meta{true} branch will be executed, else the \meta{false} branch. For the |t|
  type argument the \meta{true} branch is executed if the token was encountered.
\end{command}

\begin{command}{\pgfparserxreinsert}
  You can use this as the final macro in an action of |\pgfparserxdef| or
  |\pgfparserxdefunknown|. This has the effect that the letter which was parsed
  in this action will be parsed again after this action (and after any arguments
  were read).
\end{command}

\begin{command}{\pgfparserxstate}
  Expands to the current state of the parser.
\end{command}

\begin{command}{\pgfparserxtoken}
  This is the macro which is let to the following token with |\futurelet|. You
  can use it inside an action code.
\end{command}

\begin{command}{\pgfparserxletter}
  This macro stores the letter to which |\pgfparserxtoken| was let. So if
  you'd use |\pgfparserxrun{foo}a| this macro would be defined with
  |\def\pgfparserxletter{a}|. This definition is done before any action code is
  executed. There are two special cases: If |{| or |}| would be the next letter
  for the parser, this macro is defined to expand to |\bgroup| or |\egroup|.
\end{command}

\begin{command}{\pgfparserxset\marg{key list}}
  The |pgfparserx| module has a few keys you can access through this macro. It
  is just a shortcut for |\pgfset{/pgfparserx/.cd,#1}|. The available keys are
  listed in subsection~\ref{sec:parserx:keys}.
\end{command}

\subsection{Keys of the ParserX Module}\label{sec:parserx:keys}
\begin{key}{/pgfparserx/silent=\meta{boolean} (initially false)}
  If |true| then no error will be thrown when a letter is parsed for which no
  action is defined, silently ignoring it. This holds true for every parser.
\end{key}

\begin{key}{/pgfparserx/status=\meta{boolean} (initially false)}
  If |true| the parser prints a status message for every action executed. This
  might help in debugging and understanding what the parser does.
\end{key}

Additionally to those keys for every \meta{parser name} for which
|\pgfparserxdef| was run at least once the following will be defined:

\begin{key}
  {/pgfparserx/\meta{parser name}/silent=\meta{boolean} (initially false)}
  If |true| the parser \meta{parser name} will silently ignore undefined
  letters. This is an individual equivalent of |/pgfparserx/silent| for each
  defined parser.
\end{key}

\subsection{Examples}
The following example counts the different letters appearing in a more or less
random string of letters. Every letter is counted only once, this is achieved by
defining a new action for every encountered unknown letter that does nothing. We
can define such rule without knowing which letter is used, because
|\pgfparserxtoken| has the same meaning as that letter.
\begin{codeexample}[]
\newcount\mycountx
% using the shortcut syntax of just placing ; after the state
\pgfparserxdef{different letters}{all};{\pgfparserxswitch{final}}
\pgfparserxdefunknown{different letters}{all}
  {\pgfparserxdef{different letters}{all}\pgfparserxtoken{}\advance\mycountx1}
\pgfparserxdeffinal{different letters}
  {\the\mycountx\ different letters found}
% don't throw errors for unknown letters
\pgfparserxset{different letters/silent=true}

\pgfparserxrun{different letters}udiaternxqlchudiea;
\end{codeexample}

Next we want to try something that uses some of the different argument types
available.
\begin{codeexample}[]
% using the same syntax as \pgfparserdef
\pgfparserxdef{arguments}{initial}{the letter a}[d()]
  {\pgfparserxifmark{#1}{\textcolor{red}{\textit{use}}}{\textbf{#1}} }
% using the shortcut syntax
\pgfparserxdef{arguments}{initial}t[m]{\texttt{#1} }
\pgfparserxdef{arguments}{initial}c[t*O{blue}m]
  {\pgfparserxifmark{#1}{#3}{\textcolor{#2}{#3}}}
\pgfparserxdef{arguments}{all};{\pgfparserxswitch{final}}

\pgfparserxrun{arguments}t{nobody}a(will)ac[green]{P}c*{arser}c{X};
\end{codeexample}
